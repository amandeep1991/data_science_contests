

python django-admin.py startproject kirr
python C:\ML\installed_tools\anaconda3\envs\trydjango110\Scripts\django-admin.py startproject kirr

cd kirr\

python manage.py makemigrations

python manage.py migrate



Rename kirr (outer) to src.


Go inside src and run following commands:
	python manage.py createsuperuser
		amandeep
		amandeep.kumar@orange.com
		nffj9828

	python manage.py runserver
	Open http://127.0.0.1:8000/
	Open http://127.0.0.1:8000/admin

Create your own app:
	python manage.py startapp shortener

Open shortener/models.py and add following lines of code: (Can simply search for django model field types for different types of fields like CharField etc.)
	class kirrURL(models.Model):
	url = models.CharField(max_length=220,)
	def __str__(self):
		return str(self.url)
	# For python 2
	def __unicode__(self):
		return str(self.url)

Open shortener/admin, and add following lines of code: (to register the models)
	from .models import KirrURL
	admin.site.register(KirrURL)

Open ./src/kirr/settings.py and add following lines in list of INSTALLED_APPS:
	# custom apps
    'shortener',

Run following commands:
	python manage.py makemigrations
	pythom manage.py migrate
	python manage.py runserver


Now make changes to the model:
	shortcode = models.CharField()
	Now run python manage.py makemigrations, which will throw error that maxlength is manadatory parameter:
	ERRORS:
		shortner.KirrURL.shortcode: (fields.E120) CharFields must define a 'max_length' attribute.

	shortcode = models.CharField(max_length=15)
	Now run python manage.py makemigrations, which will throw error what to do with other fields:
	ERRORS (ALSO GIVE OPTION TO CORRECT):
		You are trying to add a non-nullable field 'shortcode' to kirrurl without a default; we can't do that (the database needs something to populate existing rows). Please select option to select.

	We need to somehow tell django that we can either make it as nullable in db or keep it blank or provide a default value, so we are going to provide a default value to it: (unique = True to make it unique)
	shortcode = models.CharField(max_length=15, default='ABCD', unique=True)




Handling migration failures:
	updated 		= models.DateTimeField(auto_now=True)
	timestamp 		= models.DateTimeField(auto_now_add=True)
	empty_timestamp = models.DateTimeField(auto_now=False, auto_now_add=False)

	Now there would be a lot of migration errors, so one option is to delete all files under shortner/migrations folder (EXCEPT __init__.py) and then also delete db.sqlite3 (now we need to create the super-user again).

	python manage.py makemigrations
	python manage.py migrate
	python manage.py createsuperuser
	amandeep
	amandeep.kumar@orange.com
	nffj9828
	nffj9828
	python manage.py runserver

To run fake migrations try following command:
	python manage.py migrate shortner --fake


Saving in the python shell (with django): DIRECTLY INTERACTING WITH DB, just to avoid few javascript validation
	python manage.py shell (this would be like of python shell just with django stuff, can be used to play with the django app)

	>>> from shortner.models import KirrURL
	>>> KirrURL.objects.all()              
	<QuerySet [<KirrURL: www.google.com>]> 



	>>> new_url = KirrURL()                  
	>>> new_url.url = 'reviewsandnotes.space'
	>>> new_url.save() 
	IntegrityError: NOT NULL constraint failed: shortner_kirrurl.empty_timestamp

	>>> import datetime.datetime
	>>> new_url.empty_timestamp = datetime.now()                      
	>>> new_url.shortcode='dfdfd'                                               
	>>> new_url.save()                                                          
	>>> KirrURL.objects.all()                                                   
	<QuerySet [<KirrURL: www.google.com>, <KirrURL: reviewsandnotes.space>]>


	>>> new_url_2 = KirrURL.objects.create()
	C:\ML\installed_tools\anaconda3\envs\trydjango110\lib\site-packages\django\db\models\fields\__init__.py:1430: RuntimeWarning: DateTimeField KirrURL.empty_timestamp received a naive datetime (2018-12-30 21:36:43.281000) while time zone support is active.RuntimeWarning)
	>>> new_url_2                           
	<KirrURL: >                             
	>>> new_url_2.url = 'www.lifeishell.com'
	>>> new_url_2.save()                                                                                         


	>>> new_url_3, is_created = KirrURL.objects.get_or_create(url='www.loveyourself.com') 
	>>> is_created                                                                        
	True                                                                                  
	>>> new_url_3.url                                                                     
	'www.loveyourself.com'                                                                
	>>> new_url_3.shortcode                                                               
	u'ABCD'                                                                                                      

	NOW CREATING IT AGAIN USING SAME WOULDN'T CREATE BUT SIMPLY GET IT
	>>> new_url_4, is_created = KirrURL.objects.get_or_create(url='www.loveyourself.com')
	>>> is_created                                                                       
	False

	SUPPOSE YOU NOW WANT TO JUST GET (MAKE A QUERY FROM THE DATABASE):
	>>> new_url_5 = KirrURL.objects.get(url='www.loveyourself.com')
	>>> new_url_5
	<KirrURL: www.loveyourself.com>
	>>> new_url_5 = KirrURL.objects.get(url='www.doesnotexists.com')
	Traceback (most recent call last):
	DoesNotExist: KirrURL matching query does not exist.


OVERRIDING SAVE METHOD:-
	Go inside KirrURL class and add following code:-

	def save(self, *args, **kwargs):
		print('print something to show that this has been called')
		super(KirrURL, self).save(*args, **kwargs)


	Now leverage this overriding concept to generate random shortcodes, so define a function (not method)
	def random_short_code_generator(size=6, chars = string.ascii_lowercase+string.digits):
		return ''.join(random.choice(chars) for _ in range(size))
	
	Now update save method:

	def save(self, *args, **kwargs):
		print('print something to show that this has been called')
		self.shortcode = random_short_code_generator()
		super(KirrURL, self).save(*args, **kwargs)

	Now even if you save button on UI, it will update the shortcode with a random number.


NOW WE DON'T WANT TO GENERATE A SHORTCODE EVERYTIME, WE SAVE ANY LINK, WE JUST WANT TO CREATE IT ONCE.
SO WE ARE GOING TO REMOVE random_short_code_generator FUNCTION AND CREATING utils.py INSIDE OUR APP ONLY, FOR ALL UTILITY FUNCTIONS.

	Also make changes in the model to allow blank values in shortcode and remove default now:-
	pre - shortcode = models.CharField(max_length=15, default='ABCD')
	post- shortcode = models.CharField(max_length=15, unique=True, blank=True)

	def save(self, *args, **kwargs):
		if self.shortcode is None or self.shortcode == '':
			self.shortcode = random_short_code_generator()
		super(KirrURL, self).save(*args, **kwargs)

MIND IT:: IF WE MAKE A FIELD UNIQUE IN THE MODEL AND TRY TO PUT SAME VALUE FROM UI, IT WILL SHOW THE ERROR MESSAGE OF 'already exists'


NOW LET'S TAKE random_short_code_generator() method to the next level, lets generate unique shortcode:
	for this we need to query like we did from django shell:
		>>> KirrURL.objects.all()
		<QuerySet [<KirrURL: www.google.com>, <KirrURL: reviewsandnotes.space>, <KirrURL: www.lifeishell.com>, <KirrURL: www.loveyourself.com>]>

	Also to do query in addition to get, we can do the following as well from django shell:-
		>>> KirrURL.objects.filter(shortcode='ABCD1') 
		<QuerySet [<KirrURL: www.lifeishell.com>]>    

	Also, single statement to check already existence:-
	>>> KirrURL.objects.filter(shortcode='ABCD1').exists()
	True

	For this when we do import KirrURL inside utils.py, it throws error as it would be cyclic dependency:
	so better use instance.__class__, so write following function in utils.py. Now call this function after importing in the model class:-


		def create_shortcode(instance, size=6):
			new_code = random_short_code_generator(size=size)
			print(instance)
			print(instance.__class__)
			print(instance.__class__.__name__)
			Kclass = instance.__class__ # this is kind of importing the class without importing the class
			new_code_exits = Kclass.objects.filter(shortcode=new_code).exists()
			if new_code_exists:
				return create_shortcode(instance, size=size)
			return new_code



LET'S DISCUSS A BIT ABOUT MODEL MANAGER AND SHORTCODE REFRESH FEATURES:
	in code KirrURL.objects.all(), objects is actually the model manager which helps us to manage different functionality or features of a model.

	create following class and assign it to objects of KirrURL: (let's take use-case where we want to show only active links, so we first need to add such field in KirrURL class)
		active = models.BooleanField(default=True)
		objects = KirrURLManager() # to attach our custom models.Manager to our Model


		class KirrURLManager(models.Manager):
			def all(self, *args, **kwargs):
				qs_original = super(KirrURLManager, self).all(*args, **kwargs)
				qs_customized = qs_original.filter(active=True)
				return qs_customized
		
		
			def refresh_shortcodes(self):
				qs = KirrURL.objects.filter(id__gte=1) # signifies id >=1
				# qs = KirrURL.objects.filter(id>=1) # signifies id >=1 wouldn't work (says sth like bool is not iterable)
				new_codes = 0
				for q in qs:
					q.shortcode = create_shortcode(q)
					print(q.shortcode)
					q.save()
					new_codes += 1
				return "New codes made: {i}".format(i=new_codes)


	WAIT FOLLOWING DIDN'T WORK:-
		>>> KirrURL.objects.all()        
		<QuerySet [<KirrURL: www.google.com>, <KirrURL: reviewsandnotes.space>, <KirrURL: www.lifeishell.com>, <KirrURL: www.loveyourself.com>]>

	THIS IS BECAUSE WE DIDN'T RESTARTED THE SHELL POST THESE CHANGES, OK!!! LET'S RESTART IT NOW::
		>>> from shortner.models import KirrURL                                 
		>>> KirrURL.objects.all()                                               
		<QuerySet [<KirrURL: www.google.com>, <KirrURL: reviewsandnotes.space>]>



		>>> from shortner.models import KirrURL  
		>>> KirrURL.objects.refresh_shortcodes() 
		2r2toi                                   
		www.google.com                           
		<class 'shortner.models.KirrURL'>        
		KirrURL                                  
		False                                    
		2r2toi                                   
		gg1mj0                                   
		reviewsandnotes.space                    
		<class 'shortner.models.KirrURL'>        
		KirrURL                                  
		False                                    
		gg1mj0                                   
		houy33                                   
		www.lifeishell.com                       
		<class 'shortner.models.KirrURL'>        
		KirrURL                                  
		False                                    
		houy33                                   
		s7z6tk                                   
		www.loveyourself.com                     
		<class 'shortner.models.KirrURL'>        
		KirrURL                                  
		False                                    
		s7z6tk                                   
		u'New codes made: 4'                     

CUSTOM DJANGO MANAGEMENT COMMANDS:- (wanted to add refresh_shortcodes command which can be triggered via cmd directly)
	Create following directory structure:
		shortner/
    		management/
    			__init__.py
    		    commands/
    				__init__.py
    		        refresh_shortcodes.py

  	Refer url: https://docs.djangoproject.com/en/2.1/howto/custom-management-commands/

  	Also inside refresh_shortcodes.py, just write following code:-

		from django.core.management.base import BaseCommand, CommandError
		class Command(BaseCommand):
		    help = 'Refreshing available shortcodes'
		    def add_arguments(self, parser):
        		parser.add_argument('these are like command line arguments which can be accessed via options variable', type=int)
		    def handle(self, *args, **options):
		        print(options)
		        return KirrURL.objects.refresh_shortcodes()

	But now you want to refresh last x (parameter to be passed via command) ids url's shortcodes, so change code to following:
		class Command(BaseCommand):
		    help = 'Refreshing available shortcodes'
		    def add_arguments(self, parser):
        		# parser.add_argument('Last X Ids', type=int) # Better to use single word
        		parser.add_argument('last_X_ids', type=int) # Adding -- make this parameter as options & in that case we need to pass this key as well so ' '(space) in between will create error ('--Last X Ids' wouldn't work)
		    def handle(self, *args, **options):
		        return KirrURL.objects.refresh_shortcodes(lastX = options['last_X_ids'])

		changes in the model manager:-
			def refresh_shortcodes(self, lastX = 100):
				qs = KirrURL.objects.filter(id__gte=1) # signifies id >=1
				# qs = KirrURL.objects.filter(id>=1) # signifies id >=1 wouldn't work (says sth like bool is not iterable)
		
				if lastX is not None and isinstance(lastX, int):
					qs = qs.order_by('-id')[:lastX] # this would make it in descending order of id 
					# (to change the default ordering of query set, add class Meta inside KirrURL)
		
				new_codes = 0
				for q in qs:
					q.shortcode = create_shortcode(q)
					print(q.id, q.shortcode)
					q.save()
					new_codes += 1
				return "New codes made: {i}".format(i=new_codes)

		OUTPUT:
			C:\ML\code\self\data_science_contests\misc\trydjango110\src (master -> origin)
			(trydjango110) λ python manage.py refresh_shortcodes 10                       
			False                                                                         
			(4, 'rbug3j')                                                                 
			False                                                                         
			(3, '17q0pf')                                                                 
			False                                                                         
			(2, 'h8tm2z')                                                                 
			False                                                                         
			(1, 'x9a2hy')                                                                 
			New codes made: 4                                                             
			                                                                              
			C:\ML\code\self\data_science_contests\misc\trydjango110\src (master -> origin)
			(trydjango110) λ python manage.py refresh_shortcodes 2                        
			False                                                                         
			(4, 'ycbno9')                                                                 
			False                                                                         
			(3, 'rwcra9')                                                                 
			New codes made: 2                                                             

		IF WE HAD MADE last_X_ids as optional argument, then we need to call it via python manage.py refresh_shortcodes --last_X_ids 2
			def add_arguments(self, parser):
        		parser.add_argument('--last_X_ids', type=int) #last_X_ids is optional now


CB views /  FB views & URLs: (Class-based view & Function based view):
	There are 2 types of views and both are defined in shortner/views.py as below:
		from django.shortcuts import render
		from django.http import HttpResponse
		from django.views import View
		# Create your views here.
		def kirr_function_based_view(request, *args, **kwargs):
			return HttpResponse('hello')
		class KirrClassBasedView(View):
			def get(self, request, *args, **kwargs):
				return HttpResponse('Hello Again!!')
	
	Now go to kirr/urls.py and add mapping of these views as below:
		from shortner.views import KirrClassBasedView, kirr_function_based_view
		urlpatterns = [
		    url(r'^admin/', admin.site.urls), # This is what we have typed as admin as suffix post simple url shown on server start on console
		    url(r'^view-1/$', kirr_function_based_view),
		    url(r'^view-2/$', KirrClassBasedView.as_view()),
		]

	Now hit following urls on browser:-
		http://127.0.0.1:8000/view-1/
		http://127.0.0.1:8000/view-2/

	One way to find all mapped urls is just give a random suffix to server, it will show all configured urls
		http://127.0.0.1:8000/djfkdjfkdjfd/
		http://127.0.0.1:8000/admin/djfkdjfkdjfd/


Please note that:
	The 'urlpatterns' list routes URLs to views.
	Example:
		Function Views:
			1. Add an import: from my_app import views
			2. Add a URL to urlpatterns: url(r'^$',views.home, name='home')
		Class-based Views:
			1. Add an import: from other_app.views import Home
			2. Add a URL to urlpatterns: url(r'^$', Home.as_view(), name='home')
		Including another URLconf:
			1. Import the include() function: from django.conf.urls import url, include
			2. Add a URL to urlpatterns: url(r'^blog/', include('blog.urls'))

Using parameters from django settings (application properties in python/django file):
	Open file kirr/settings.py and add following properties:
		SHORT_CODE_MAX_LENGTH = getattr(settings, "SHORT_CODE_MAX_LENGTH", 15)
	Inside shortner/models.py, please add/change following code:
		# SHORT_CODE_MAX_LENGTH = settings.SHORT_CODE_MAX_LENGTH
		# It's better to use following because of few reasons: Reusable Application 
		# [15 is the default value if not set in properties]
		SHORT_CODE_MAX_LENGTH = getattr(settings, "SHORT_CODE_MAX_LENGTH", 15)

		shortcode = models.CharField(max_length=SHORT_CODE_MAX_LENGTH, blank=True, unique=True)

URL Keyword Arguments:
	One possible error/mistake we can do with trydjango1.10: Adding following url-mapping:-
		url(r'^abc/$', 'shortner.views.KirrClassBasedView') 
		# we can't pass this string, instead we need to import it, example for function based views.

	Parsing URL as key-value arguments, please update following to mentioned:-
		url(r'^view-1/$', kirr_function_based_view),
    	url(r'^view-2/$', KirrClassBasedView.as_view()),
		
		url(r'^(?P<shortcode>[\w-]+)/$', kirr_function_based_view),
    	url(r'^(?P<shortcode>[\w-]+)/$', KirrClassBasedView.as_view()),

		Now if we print kwargs in view, and hit 'http://127.0.0.1:8000/dljfdkfjdlfdf/', following will be printed:
			{'shortcode': u'dljfdkfjdlfdf'}

	We can also change our view to accept this argument by default by changing the defination of views to below [IN THIS CASE kwargs WOULD BE EMPTY]:-
		Code Change: (/shortner/views.py in both function and method)
				#Put shortcode=None just to be on safer side
			def kirr_function_based_view(request, shortcode=None, *args, **kwargs): 
				print('kwargs: ', kwargs)
				print('shortcode: ', shortcode)
				return HttpResponse('hello')
			
			class KirrClassBasedView(View):
				def get(self, request, shortcode=None, *args, **kwargs):
					print('kwargs: ', kwargs)
					print('shortcode: ', shortcode)
					return HttpResponse('Hello Again!!')
		Output:
			('kwargs: ', {})
			('shortcode: ', u'dljfdkfjdlfdf')

	In urls mapping we can also give sub resource directory as well:-
			url(r'^a/(?P<shortcode>[\w-]+)/$', kirr_function_based_view),
    		url(r'^b/(?P<shortcode>[\w-]+)/$', KirrClassBasedView.as_view()),
    	Now hit both of these urls:-
    		'http://127.0.0.1:8000/a/dljfdkfjdlfdf/'
    		'http://127.0.0.1:8000/b/dljfdkfjdlfdf/'

		Now if you hit http://127.0.0.1:8000/dljfdkfjdlfdf/, it will print following message on command prompt and on browser it will show all valid patterns
			Not Found: /dljfdkfjdlfdf/

Quering shortcode from database:
	This would require changes to be done in view, we would simply validate the shortcode using KirrURL.objects.get(shortcode=shortcode) like below:-
			from .models import KirrURL

			# Create your views here.
			def kirr_function_based_view(request, shortcode=None, *args, **kwargs):
				print('kwargs: ', kwargs)
				print('shortcode: ', shortcode)
				obj = KirrURL.objects.get(shortcode=shortcode)
				return HttpResponse('helloooooo url[{}]. You hit A.'.format(obj.url))
			
			class KirrClassBasedView(View):
				def get(self, request, shortcode=None, *args, **kwargs):
					print('kwargs: ', kwargs)
					print('shortcode: ', shortcode)
					obj = KirrURL.objects.get(shortcode=shortcode)
					return HttpResponse('Hello Again, url[{}]. You hit B.'.format(obj.url))
		
		If shortcode not found (like if you hit http://127.0.0.1:8000/a/dljfdkfjdlfdf/) then following exception message get's printed on command prompt and browser would also output nearly the same:
						DoesNotExist: KirrURL matching query does not exist.

		But if you hit http://127.0.0.1:8000/a/y8yuf0/, following html get's returned (with some extra divs):
			helloooooo url[www.loveyourself.com]. You hit A. 
		similarly if you hit http://127.0.0.1:8000/b/y8yuf0/, following html get's returned (with some extra divs):
			Hello Again, url[www.loveyourself.com]. You hit B. 


	Now to solve the issue where shortcode doesn't exists, try to write following code (simply returns first url if shortcode doesn't present)
		# Create your views here.
		def kirr_function_based_view(request, shortcode=None, *args, **kwargs):
			print('kwargs: ', kwargs)
			print('shortcode: ', shortcode)
			try:
				obj = KirrURL.objects.get(shortcode=shortcode)
				url = obj.url
			except:
				obj = KirrURL.objects.first()
				url = obj.url + " (DEFAULT)"
			return HttpResponse('helloooooo url[{}]. You hit A.'.format(url))

	This is the right solution, it's better to use filter so that something matching get's found: (for new shortcode it will return None which makes sense as well)
		# Create your views here.
		def kirr_function_based_view(request, shortcode=None, *args, **kwargs):
			print('kwargs: ', kwargs)
			print('shortcode: ', shortcode)
			url = None
			qs = KirrURL.objects.filter(shortcode__iexact = shortcode.upper())
			if qs.exists() and qs.count() ==1:
				obj = qs.first()
				url = obj.url
			return HttpResponse('helloooooo url[{}]. You hit A.'.format(url))

	There is one more thing in this 'from django.shortcuts import get_object_or_404':
		# Create your views here.
		def kirr_function_based_view(request, shortcode=None, *args, **kwargs):
			obj = get_object_or_404(KirrURL, shortcode = shortcode)
			return HttpResponse('helloooooo url[{}]. You hit A.'.format(obj.url))

		This will return page not found 404, in case new shortcode will be passed in url. (Preferred approach)


	Please note that for class based fews we have to specifically define methods for different call types (GET, POST). But if we need to know the request type we can simply use request.method.

NOTE:
	In current code there is discrepancy between:
			obj = get_object_or_404(KirrURL, shortcode = shortcode)
		and
			obj = KirrURL.objects.get(shortcode=shortcode)
	Please note that line #1 actually hits KirrURL.objects.all() first of all which we have over-loaded.
	That's why it's results are different.

To keep that customization intact + avoid any issues related to active/inactive, we will keep every entry as active:
    So make entry with shortcode='a' as active.

HttpResponse Redirect & URL Ordering:
	To redirect just use following:-
		Replace:
			return HttpResponse('helloooooo url[{}]. You hit A.'.format(obj.url))
		By:
            def kirr_function_based_view(request, shortcode=None, *args, **kwargs):
	            obj = get_object_or_404(KirrURL, shortcode = shortcode)
	            return HttpResponseRedirect(obj.url)
        Please note that if obj.url starts with http:// or https:// only then it will consider it as external url otherwise it will consider it as internal relative position of resource so it will just appends what's been passed in HTTPResponseRedirect, even www wouldn't work here.

    Now I want to limit the number of characters in the url for shortcode regex, need to do following:
            {lower_limit, upper_limit}
        in urls.py, replace following:
            url(r'^a/(?P<shortcode>[\w-]+)/$', kirr_function_based_view),
        with following:
            url(r'^a/(?P<shortcode>[\w-]+){6,15}/$', kirr_function_based_view),
        now if we hit following urls:
            http://127.0.0.1:8000/a/a --> tells us about the error with the possible patterns (it's didn't use get_object_or_404's 404 page because url matching is happening first and then it can find the possible views where it might have tried get_object_or_404 but it didn't reach till that point.
            http://127.0.0.1:8000/a/adfdfdfd/ --> it shows 404 from the get_object_or_404 shortcut utility provided by django.

    Also please note that ordering of URL MAPPINGS in urls.py also matters, the execution goes to the first view mapping which met the regular expression.


SECTION 3:: LECTURE 23: LOCALLY TESTING A DOMAIN NAME:
    Need to add hosts in /etc/hosts: (in windows update c:\Windows\System32\Drivers\etc\hosts)
        127.0.0.1 kirr.com
        127.0.0.1 www.kirr.com
        127.0.0.1 blog.kirr.com

    We need to allow hosts in kirr/settings.py file:
        ALLOWED_HOSTS = [] (just above it there is a parameter for debug=True)


SECTION 3:: LECTURE 24: USING django-hosts FOR SUB-DOMAIN HANDLING
    'django-hosts' will be helpful to redirect following:
        blog.kirr.com -> kirr.com
        abc.kirr.com -> kirr.com
        etc

    Now do following steps for adding django-hosts in your project: (https://django-hosts.readthedocs.io/en/latest/)
        Install the package first.
            1. Add 'django_hosts' to your INSTALLED_APPS setting.
            2. Add 'django_hosts.middleware.HostsRequestMiddleware' to the beginning of your MIDDLEWARE or MIDDLEWARE_CLASSES setting.
            3. Add 'django_hosts.middleware.HostsResponseMiddleware' to the end of your MIDDLEWARE or MIDDLEWARE_CLASSES setting.
            4. Create a new module containing your default host patterns, e.g. in the hosts.py file next to your urls.py.
            5. Set the ROOT_HOSTCONF setting to the dotted Python import path of the module containing your host patterns, e.g.:

        Important point to note:
            Middleware happens between urls.py (mapping) and actual call to the mapped view. (that's why we have added one middleware on top and other in the bottom.

            blogs.reviewsandnotes.space still not working, so did following:-
                created a module under kirr directory:
                    hostsconf
                        / __init__.py
                        / urls.py
                        / views.py

                Add following code in these and then hit (http://courses.reviewsandnotes.space:8000/admin/) it will redirect to (http://www.reviewsandnotes.space:8000/admin/)




GOLDER RULE: if you update any app or it's model, please run following 2 commands to make it all the new changes in the model inline with django db:-
	python manage.py makemigrations
	python manage.py migrate